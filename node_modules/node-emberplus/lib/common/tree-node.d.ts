import { ExtendedReader as Reader, ExtendedWriter as Writer } from '../ber';
import { Command } from './command';
import { InvocationResult } from './invocation-result';
import { StreamCollection } from './stream/stream-collection';
import { FunctionContents } from './function/function-contents';
import { ParameterContents } from './parameter-contents';
import { NodeContents } from './node-contents';
import { MatrixContents } from './matrix/matrix-contents';
import { FunctionArgument } from './function/function-argument';
import { ElementBase } from './element.base';
export declare class TreeNode extends ElementBase {
    get description(): string | null;
    set description(description: string);
    get identifier(): string | null;
    set identifier(identifier: string);
    get number(): number;
    get path(): string;
    get contents(): FunctionContents | ParameterContents | NodeContents | MatrixContents | null;
    _parent: TreeNode;
    elements: Map<string | number, TreeNode | Command | InvocationResult>;
    protected _result?: InvocationResult;
    protected _contents?: FunctionContents | ParameterContents | NodeContents | MatrixContents;
    protected _number?: number;
    protected _path?: string;
    protected _seqID: number;
    private _subscribers;
    private streams?;
    constructor();
    static addElement(parent: TreeNode, element: TreeNode | Command): void;
    static decode(ber: Reader): TreeNode | Command | InvocationResult;
    static path2number(path: string): number;
    static createElementTree(node: TreeNode): TreeNode;
    _isSubscribable(callback: (x: TreeNode) => void): boolean;
    _isAutoSubscribable(callback: (x: TreeNode) => void): boolean;
    _subscribe(callback: (x: TreeNode) => void): void;
    _unsubscribe(callback: (x: TreeNode) => void): void;
    addChild(child: TreeNode | Command): void;
    addElement(element: TreeNode | Command): void;
    clear(): void;
    encode(ber: Writer): void;
    encodeNumber(ber: Writer): void;
    encodePath(ber: Writer): void;
    getSubscribersCount(): number;
    getNewTree(): TreeNode;
    hasChildren(): boolean;
    isRoot(): boolean;
    getMinimalContent(): any;
    getDuplicate(): TreeNode;
    getMinimal(): TreeNode;
    getTreeBranch(child?: ElementBase, modifier?: (x: TreeNode) => void): TreeNode;
    getRoot(): TreeNode;
    getCommand(cmd: Command): TreeNode;
    getDirectory(callback: (x: TreeNode) => void): TreeNode;
    getChildren(): (TreeNode | Command | InvocationResult)[] | null;
    getNumber(): number;
    getParent(): TreeNode;
    getElementByPath(path: string | number[]): TreeNode;
    getElementByNumber(number: number): TreeNode | Command | InvocationResult;
    getElementByIdentifier(identifier: string): TreeNode;
    getElement(id: number | string): TreeNode | Command | InvocationResult;
    getPath(): string;
    getResult(): InvocationResult | null;
    invoke(params: FunctionArgument[]): TreeNode;
    setResult(result: InvocationResult): void;
    setStreams(streams: StreamCollection): void;
    getStreams(): StreamCollection;
    subscribe(callback: (x: TreeNode) => void): TreeNode;
    getJSONContent(): {
        [index: string]: any;
    };
    toJSON(): {
        [index: string]: any;
    };
    toElement(): TreeNode;
    toQualified(): TreeNode;
    unsubscribe(callback: (x: TreeNode) => void): TreeNode;
    update(other: TreeNode): boolean;
    updateSubscribers(): void;
    protected decodeChildren(ber: Reader): void;
    protected encodeChildren(ber: Writer): void;
    protected setContent(key: string, value: any): void;
    protected setPath(path: string): void;
    protected setNumber(number: number): void;
    protected setContents(contents: FunctionContents | ParameterContents | NodeContents | MatrixContents): void;
}
